classdef DataUnit2DataUnit
    %
    % This class allows to format DataUnit for processing pipeline. Data
    % are formatted to fit with model requirements as well as making or 
    % modifying new Data Unit after processing step.
    %
    % see also BLOC2ZONE, ZONE2DISP, DATAUNIT, PROCESSDATAUNIT
    
    properties
        DataField = {'x','y','dy','mask'}; % define the field 
                                           % corresponding to data in DataUnit
        ForceDataCat@logical = false; %logical that forces data concatenation. 
                                      %Example: 
                                      % -false: Bloc() --> data_formated
                                      % is a BRLX x NBLK array of structure
                                      % where each field is 1xBS vector
                                      % -true: Bloc() --> data_formated
                                      % is a 1 x 1 array of structure
                                      % where each field is BS x NBLK x
                                      % BRLX matrix.
       ForceChildCreation@logical = false;  % force child creation when
                                            % parent DataUnit has children
                                            % with same class as the wanted
                                            % one for child creation.
    end
    
    properties (Abstract)
        OutputChildClass@char %define the class of the child object
    end
    
    methods
        % Constructor
        function this = DataUnit2DataUnit()
            
        end %DataUnit2DataUnit
        
        % Format DataUnit data in an array of structure with the following
        % field: x, y, dy, mask (See DataUnit property).
        % Dimension of the array of structure depends on the input class:
        % - Bloc: data_formated is a NBLK x BRLX array of struct where each
        %         field is a BS x 1 vector
        % - Zone: data_formated is a BRLX x 1 array of struct where each
        %         field is a NBLK x 1 vector
        % - Dispersion: data_formated is a 1 x 1 array of struct where each
        %         field is a BRLX x 1 vector
        % 
        % If ForceDataCat property is set to true data_formated will be a
        % 1 x 1 structure where each field has the same size than the input
        % class:
        % Bloc: BS x NBLK x BRLX
        % Zone: NBLK x BRLX
        % Dispersion: BRLX x 1
        %
        function data_formated = getProcessData(this, DataUnit)
            % check input
            if ~isa(DataUnit,'DataUnit')
                data_formated = []; return
            end
            
            % get data dim
            dim = size(DataUnit.y);
            
            % cast dim in 3D
            if numel(dim) < 3; dim(3) = 1; end
                            
            % check if ForceDataCat is true
            if this.ForceDataCat
                % get data as is and prepare struct input
                for k = numel(this.DataField):-1:1
                    % field
                    varargin{2*k-1} = this.DataField{k}; 
                    % data
                    varargin{2*k} = DataUnit2DataUnit.checkSize(DataUnit.(this.DataField{k}), dim);
                end
                % create struct
                data_formated = struct(varargin{:});
            else
                % init to force appropriate orientation
                C = cell(numel(this.DataField), dim(2), dim(3));
                % loop over the field
                for k = 1:numel(this.DataField)
                    % get data
                    data = DataUnit2DataUnit.checkSize(DataUnit.(this.DataField{k}), dim);
                    % convert data to cell array
                    C(k,:,:) = mat2cell(data,...
                        dim(1),repelem(1,dim(2)),repelem(1,dim(3)));
                end
                % convert to array of struct
                data_formated = cell2struct(C, this.DataField, 1);
            end
        end %getProcessData    
        
        % Format processed data to make new DataUnit object. Input size
        % need to respect the format from getProcessData output:
        % - Bloc: data_formated is a NBLK x BRLX array of struct where each
        %         field is a (BS,1) x N vector
        % - Zone: data_formated is a BRLX x 1 array of struct where each
        %         field is a (NBLK,1) x N vector
        % - Dispersion: data_formated is a 1 x 1 array of struct where each
        %         field is a (BRLX,1) x N vector
        %
        % N is the number of object to create (Biexp: 2 object, Monoexp: 1
        % obj,...)
        % (BS,1): can take these two values. If Dispersion is filtered, it
        % will returned the same size object 1 x BRLX. On the other hand,
        % if Zone is fitted with Monoexp, each field will be 1 x 1 (T1).
        % 
        function DataUnit_child = makeProcessData(this, data_formated, DataUnit_parent)
            % check input
            if ~isa(DataUnit_parent,'DataUnit')
                DataUnit_child = []; return
            end
            
            % if no data, return parent object
            if isempty(data_formated); DataUnit_child = DataUnit_parent; return; end
            
            % get fieldnames and number of object
            fld = fieldnames(data_formated);
            n = size(data_formated(1,1).(fld{1}),2); %number of object to create
            
            % init
            data = cell(1,2*numel(fld)); data(1:2:end) = f
            % check if output data are singleton along first dimension. If
            % not, data were just modified and not converted into a new
            % class (filtering,...).
            if size(data_formated(1,1).(fld{1}),1) > 1
                % loop over the field
                for k = numel(fld):-1:1
%                     % loop over the object
%                     for i = 1:n
%                         val = arrayfun(@(x) x.(fld{k})(:,i), data_formated, 'Uniform', 0);
%                         val = [val{:}];
%                         % reshape
%                         val = reshape(val,[size(val,1), size(data_formated)]);
%                         % convert into cell array
%                         data{2*k} = [data{2*k}, val];
%                         data{2*k-1} = fld{k};
%                     end
%                     % other way: faster
                    val2 = vertcat(data_formated.(fld{k}));
                    data{2*k} = reshape(val2,[size(data_formated(1,1).(fld{1}),1), size(data_formated), n]);
%                     % check if identical
%                     if isequal(val2, DataUnit_parent.(fld{k}))
%                         disp('Ok!')
%                     end
                end
            else
                % loop over the field
                for k = numel(fld):-1:1
                    % get data
                    val = vertcat(data_formated.(fld{k}));
                    % reshape
                    val = reshape(val,[size(data_formated),n]);
                    % convert into cell array
                    data{2*k} = mat2cell(val,[1 1 repelem(1,n)]);
                end
                    
            end
            
            % get the output class
            fh = str2func(this.OutputChildClass);
            
            if isempty(DataUnit_parent.children)
                % create child DataUnit
                DataUnit_child = fh('parent',repmat({DataUnit_parent},1,n), data{:});
            else
                % check the class of parent's children class and if the
                % same and flag is false update the parent's children
                % object. Else delete children.
                if strcmp(this.OutputChildClass, class(DataUnit_parent.children)) &&...
                        ~this.ForceChildCreation
                   % count children and create/delete/update in function
                   DataUnit_child = Data_parent.children;
                   nChild = numel(DataUnit_child);
                   if nChild < n
                       % loop over the field
                       for k = 1:fld
                           % get data and fill children
                           val = data{2*k}(1:nChild);
                           [DataUnit_child.(fld{k})] = val{:};
                           % remove used data
                           data{2*k}(1:nChild) = [];
                       end
                       % add new data
                       DataUnit_child = fh('parent',...
                           repmat({DataUnit_parent},1,n-nChild), data{:});
                   elseif nChild > n
                       % remove some children
                       for k = 1:(nChild - n)
                           delete(DataUnit_child(1));
                           DataUnit_child(1) = []; %clear
                       end
                       % update data
                       for k = 1:fld
                           [DataUnit_child.(fld{k})] = data{2*k}{:};
                       end
                   else
                       % update data
                       for k = 1:fld
                           [DataUnit_child.(fld{k})] = data{2*k}{:};
                       end    
                   end
                else
                   % delete all the children of parent
                   while ~isempty(DataUnit_parent.children)
                       delete(DataUnit_parent(1).children)
                       DataUnit_parent(1).children = []; %clear
                   end
                   % create child DataUnit
                   DataUnit_child = fh('parent',repmat({DataUnit_parent},1,n), data{:});
                end
            end
        end %makeProcessData
    end
    
    methods (Static)        
        % Check if a matrix corresponds to a given size. If false, complete
        % the matrix with NaN to get the final matrix
        function data_checked = checkSize(data, dim)
            % check size
            s = size(data);
            
            % cast size in 3D
            if numel(s) < 3; s(3) = 1; end
            
            % check size and complete with NaN if required
            if isequal(s, dim)
                data_checked = data;
                return
            elseif isempty(data)
                data_checked = nan(dim);
            else
                data_checked = nan(dim);
                data_checked(1:s(1),1:s(2),1:s(3)) = data;
            end
        end %checkSize   
    end
    
end

