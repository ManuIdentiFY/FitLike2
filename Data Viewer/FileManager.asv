classdef FileManager < handle
    %
    % View for FileManager in FitLike
    %
    
    properties
        gui % GUI (View)
        FitLike % Presenter
    end
    
    % Icons properties
    properties
        DatasetIcon = fullfile(matlabroot,'toolbox','matlab','icons','foldericon.gif');
        SequenceIcon = fullfile(matlabroot,'toolbox','matlab','icons','greencircleicon.gif');
        FileIcon = fullfile(matlabroot,'toolbox','matlab','icons','HDF_filenew.gif');
        RelaxObjIcon = fullfile(matlabroot,'toolbox','matlab','icons','HDF_object02.gif');
    end
    
    methods (Access = public)
        % Constructor
        function this = FileManager(FitLike)
            % import tree package
            import uiextras.jTree.*
            %%--------------------------BUILDER--------------------------%%
            % Store a reference to the presenter
            this.FitLike = FitLike;
                      
            % Make the figure
            this.gui.fig = figure('Name','File Manager','NumberTitle','off',...
                'MenuBar','none','ToolBar','none','Units','normalized',...
                'Position',[0 0.1 0.24 0.75],'Tag','fig');
            
            % Make the tree
            this.gui.tree = CheckboxTree('Parent',this.gui.fig,...
                'Editable',true, 'DndEnabled',true,...
                'NodeDraggedCallback', @(s,e) FileManager.DragDrop_Callback(s,e),...
                'NodeDroppedCallback', @(s,e) FileManager.DragDrop_Callback(s,e),...
                'Tag','tree','RootVisible',false);           
            %%-------------------------CALLBACK--------------------------%%
            % Replace the close function by setting the visibility to off
            set(this.gui.fig,  'closerequestfcn', ...
                @(src, event) this.FitLike.hideWindowPressed(src));  
          
        end %FileManager
        
        % Destructor
        function deleteWindow(this)
            %remove the closerequestfcn from the figure, this prevents an
            %infitie loop with the following delete command
            set(this.gui.fig,  'closerequestfcn', '');
            %delete the figure
            delete(this.gui.fig);
            %clear out the pointer to the figure - prevents memory leaks
            this.gui = [];
        end  %deleteWindow   
    end
    
    methods (Access = public)
        % Add new data to the tree
        function this = addData(this, dataset, sequence, filename, displayName)
            % check input type
            if ischar(dataset) && ischar(sequence) && ischar(filename)
                % convert to cell
                dataset = {dataset};
                sequence = {sequence};
                filename = {filename};
                displayName = {displayName};
            elseif iscell(dataset) && iscell(sequence) && iscell(filename)
                % check if size is consistent
                if ~isequal(length(dataset),length(sequence)) ||...
                        ~isequal(length(dataset),length(filename))
                    error('FileManager:addData','Input size is not consistent')
                end
            else
                error('FileManager:addData','Input type is not consistent')
            end
            
            % import tree package
            import uiextras.jTree.*      
            
            % loop over the input
            for k = 1:length(dataset)
                % + dataset
                hDataset = FileManager.checkNodeExistence(this.gui.tree.Root,...
                    dataset{k}, this.DatasetIcon, 'dataset');
                % + sequence
                hSequence = FileManager.checkNodeExistence(hDataset,...
                    sequence{k}, this.SequenceIcon, 'sequence');
                % + filename
                hFile = FileManager.checkNodeExistence(hSequence,...
                    filename{k}, this.FileIcon, 'file');
                % + relaxobj
                FileManager.checkNodeExistence(hFile, displayName{k},...
                    this.RelaxObjIcon, 'relaxObj');
            end
        end %addData
        
        % Remove data from the tree
        function this = removeData(this)
               % just delete the selected nodes and their children
               delete(this.gui.tree.CheckedNodes);
        end %removeData
        
        % Get the fileID list of the selected nodes
        function fileID = getIDofSelectedNodes(this)
            % get the list of the selected nodes
            hSelected = this.gui.tree.CheckedNodes;           
            % get fileID by checking the value of the checked node
            fileID = [hSelected.Value];
        end %getIDofSelectedNodes
    end
    
    methods (Access = public, Static = true)
        % this function determines if the dragged target is valid or not.
        % All target are valid except relaxObj.
        function DropOk = DragDrop_Callback(tree, event)
            % Is this the drag or drop part?
            DoDrop = ~(nargout); % The drag callback expects an output, drop does not

            % get source and target
            src = event.Source;
            target = event.Target;
            
            % Check if the source & target are valid:
            % *User can drag dataset, sequence and file
            % *File can be dropped in sequence or file
            % *Sequence can be dropped in dataset or sequence
            % *Dataset can be dropped in dataset
            if strcmp(src.Value,'file') &&...
                  (strcmp(target.Value,'sequence') || strcmp(target.Value,'file'))
                % file to sequence/file
                DropOk = true;
            elseif strcmp(src.Value,'sequence') &&...
                  (strcmp(target.Value,'dataset') || strcmp(target.Value,'sequence')) 
                % sequence to dataset/sequence
                DropOk = true;
            elseif strcmp(src.Value,'dataset') && strcmp(target.Value,'dataset')
                % dataset to dataset
                DropOk = true;
            else
                % invalid target or source
                DropOk = false;
            end

            % If drop is allowed
            if DoDrop && strcmpi(event.DropAction,'move')
                % Get list of children in target container
                hChildren = [target.Parent.Children];
                % Get index or source and target
                idxTarget = find(hChildren == target);
                idxSource = find(hChildren == src);
                % check if we change nodes or not
                if src.Parent ~= target.Parent
                    % store parent handle for updating
                    hSrcParent = src.Parent;
                    % check if target type is the same as source type
                    if ~strcmp(src.Value, target.Value)
                        hChildren = target.Children;
                    end   
                    % check if duplicate
                    tf = isDuplicate(hChildren, src, target);
                    if tf
                        return
                    end
                    % De-parent
                    src.Parent = [];
                    % check if target type is the same as source type
                    if ~strcmp(src.Value, target.Value)
                        % file to sequence or sequence to dataset: target
                        % is the new parent
                        src.Parent = target;
                        % reorder children to get the new children in first
                        % position
                        n = numel(target.Children);
                        FileManager.stackNodes(tree, target.Children,[n, 1:n-1]);
                    else
                        % prepare re-ordering
                        new_order = [1:(idxTarget-1) NaN idxTarget:numel(hChildren)];
                        % reorder children
                        FileManager.stackNodes(tree, hChildren, new_order, src);
                    end
                    % delete old parent if no more children
                    if isempty(hSrcParent.Children)
                        delete(hSrcParent)
                    end
                else                 
                    % prepare re-ordering
                    new_order = 1:numel(hChildren);
                    new_order(idxTarget) = idxSource; 
                    new_order(idxSource) = idxTarget;
                    % reorder children
                    FileManager.stackNodes(tree, hChildren, new_order);
                end
            end
            
            function isDuplicate(hChildren, src, target)
                % check if duplicate
                stf = strcmp({hChildren.Name}, src.Name);
                if ~all(stf == 0)
                    % throw warning
                    wmsg = sprintf(['You can not drop your %s as is in this %s '...
                        'because it already contains the same %s: %s.'],src.Value,...
                        src.Parent.Value, target.Value, target.Name);
                    warndlg(wmsg, 'Warning: duplicate');
                    return
                end
            end
        end %DragNodeCallback
        
        % This function allow to reorder nodes. A new node can also be
        % insert at the position indicates by 'NaN'.
        % Example: hNodes = stackNodes(tree, hNodes,[1 3 2]);
        %          hNodes = stackNodes(tree, hNodes,[1 3 NaN 4),newNode);
        function stackNodes(tree, hNodes, new_order, varargin)
            % check if a new node need to be inserted
            if isempty(varargin) && numel(hNodes) == numel(new_order)
                % re-order nodes
                hNodes = hNodes(new_order);
                % re-parent to finish the process
                FileManager.reparentNodes(tree, hNodes, hNodes(1).Parent);  
            elseif isa(varargin{1},'uiextras.jTree.CheckboxTreeNode')
                % get parent
                hParent = hNodes(1).Parent;
                % stack new node
                hNodes = [hNodes varargin{1}];
                % replace scalar '0'
                new_order(isnan(new_order)) = numel(hNodes);
                % re-order nodes
                hNodes = hNodes(new_order);
                % re-parent to finish the process
                FileManager.reparentNodes(tree, hNodes, hParent);                
            end
        end %stackNodes
        
        % re-parent nodes: need to be done explicitely
        function reparentNodes(tree, hNodes, hParent)
            % set visibility of the tree 'off' to avoid display issues
            tree.Visible = 'off';
            for k = 1:numel(hNodes)
                hNodes(k).Parent = hParent;
            end
            tree.Visible = 'on';
        end %reparentNodes
        
        % Check node existence and create it if needed. This function looks
        % in the parent handle node the children's name and check if the
        % wanted name exists or not. If is exists checkNodeExistence return
        % the corresponding children handle. If it does not,
        % checkNodeExistence create a new Children in hParent with the
        % wanted name and return the new children handle.
        % this function also take an icon and a type (dataset, sequence,...)
        % that will be add to the new children.
        function hChildren = checkNodeExistence(hParent, nodeName, icon, type)
            % import tree package
            import uiextras.jTree.*
            % check if children
            if isempty(hParent.Children)
                hChildren = CheckboxTreeNode('Parent', hParent,...
                                             'Name', nodeName,...
                                             'Value', type);
                setIcon(hChildren,icon);                         
            else
                % check if the wanted name corresponds to a children in the
                % parent container
                tf = strcmp(get(hParent.Children,'Name'),nodeName);
                % if true, get the handle. If false, create new node
                if all(tf == 0)
                    hChildren = CheckboxTreeNode('Parent',hParent,...
                                                 'Name',nodeName,...
                                                 'Value',type);
                    setIcon(hChildren,icon);  
                else
                    hChildren = hParent.Children(tf);
                end
            end
        end %checkNodeExistence
    end   
end

